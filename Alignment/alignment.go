package main

import (
	"fmt"
	"os"
	"strings"
)

//Multiple Sequence Alignment -- Star heuristic
//Input: gene sequences or FASTA files from different species
//Output: a distance matrix of these sequences derived from the multiple sequence alignment

func main() {

	//input files are multiple FASTA files
	genes := []string{}
	speciesName := []string{}
	//loop through each input FASTA files, store the content to a string, and append it to genes
	for _, filename := range os.Args[1:] {
		file, err := os.Open(filename)
		if err != nil {
			fmt.Println("Error: couldn't open the file")
			os.Exit(1)
		}
		defer file.Close()
		species := filename[:strings.IndexByte(filename, '.')]
		speciesName = append(speciesName, species)
		gene := ReadGeneFromFile(filename)
		genes = append(genes, gene)
	}
	fmt.Println("We have read genes from file.")

	/*
		//test case
		gene1 := "ATTCGGATT"
		gene2 := "ATCCGGATT"
		gene3 := "ATGGAATTTT"
		gene4 := "ATGTTGTT"
		gene5 := "AGTCAGG"
		genes := []string{gene1, gene2, gene3, gene4, gene5}
		speciesName := []string{"gene1", "gene2", "gene3", "gene4", "gene5"}
		fmt.Println(AlignGenes(gene1, gene2, 1, -1, -2))
		fmt.Println(AlignGenes(gene1, gene3, 1, -1, -2))
		fmt.Println(AlignGenes(gene1, gene4, 1, -1, -2))
		fmt.Println(AlignGenes(gene1, gene5, 1, -1, -2))
		fmt.Println("*******************************************")
	*/

	msa := MultipleAlignment(genes, 1, -1, -2)
	fmt.Println("Multiple Sequence Alignment have succeeded!")
	// for i := range msa {
	// 	fmt.Println(msa[i])
	// 	fmt.Println(len(msa[i]))
	// }
	matrix := DistanceMatrix(msa)
	fmt.Println(matrix)
	WriteMatrixToFile(speciesName, matrix, "distanceMatrix.txt")
	fmt.Println("We have finishing writing the distance matrix to file!")
}

//Part 1: Pairwise Alignment

//AlignGenes will take two genes as input with factors for Needleman-Wunsch algorithm and returns the alignment of the two genes.
func AlignGenes(gene1, gene2 string, reward, penalty, gap int) []string {
	return Traceback(gene1, gene2, reward, penalty, gap, NWMatrix(gene1, gene2, reward, penalty, gap))
}

//NWMatrix uses Needleman-Wunsch algorithm to build a matrix. Each cell in the matrix represents a partial alignment.
//The matrix can then be used to traceback and find the alignment of the two gene inputs.
func NWMatrix(gene1, gene2 string, reward, penalty, gap int) [][]int {
	//initialize the matrix
	matrix := make([][]int, len(gene1)+1)
	for row := range matrix {
		matrix[row] = make([]int, len(gene2)+1)
	}
	//Fill in the first row and first column to the matrix.
	//First row and first column represent gap.
	for row := range matrix {
		for column := range matrix[row] {
			matrix[row][0] = gap * row
			matrix[0][column] = gap * column
		}
	}
	//Loop through and fill out the rest cells in the matrix
	for r := 1; r < len(matrix); r++ {
		for c := 1; c < len(matrix[r]); c++ {
			diagonal := matrix[r-1][c-1] + Match(gene1[r-1:r], gene2[c-1:c], reward, penalty)
			left := matrix[r][c-1] + gap
			up := matrix[r-1][c] + gap
			//Each cell is determined by the maximum among cell on its left, cell on its up, and cell on its diagonal
			matrix[r][c] = MaxBtwThree(diagonal, left, up)
		}
	}
	return matrix
}

//Match takes two nucleotides as input and checks if they are the same.
func Match(n1, n2 string, reward, penalty int) int {
	if n1 == n2 {
		return reward
	} else {
		return penalty
	}
}

//MaxBtwThree takes three integers as inputs and return the maximum among them.
func MaxBtwThree(diagonal, left, up int) int {
	return MaxBtwTwo(MaxBtwTwo(diagonal, left), up)
}

//MaxBtwTwo takes two integers as inputs and return the maximum between them.
func MaxBtwTwo(a, b int) int {
	if a > b {
		return a
	} else {
		return b
	}
}

//Traceback takes two genes sequences, the matrix generated by Needleman-Wunsch algorithm as inputs
//and returns a slice containing the sequences of the two genes after alignment
func Traceback(gene1, gene2 string, reward, penalty, gap int, matrix [][]int) []string {
	align1 := "" //align1 will record gene1 after alignment
	align2 := "" //align2 will record gene2 after alignment

	r := len(gene1)
	c := len(gene2)

	for r*c != 0 {
		//If the matrix[r][c] is from its diagonal cell
		if matrix[r][c] == matrix[r-1][c-1]+Match(gene1[r-1:r], gene2[c-1:c], reward, penalty) {
			align1 += gene1[r-1 : r]
			align2 += gene2[c-1 : c]
			r--
			c--
			//If the matrix[r][c] is from its left cell
		} else if matrix[r][c] == matrix[r][c-1]+gap {
			align1 += "-"
			align2 += gene2[c-1 : c]
			c--
			//If the matrix[r][c] is from its up cell
		} else {
			align1 += gene1[r-1 : r]
			align2 += "-"
			r--
		}
	}

	//if r (gene1) still has nucleotides that have not covered by traceback
	for r != 0 {
		align1 += gene1[r-1 : r]
		align2 += "-" //add gap to the alignment of gene2
		r--
	}

	//if c (gene2) still has nucleotides that have not covered by traceback
	for c != 0 {
		align1 += "-" //add gap to the alignment of gene1
		align2 += gene2[c-1 : c]
		c--
	}

	//The actual sequence should be the reverse of align1
	align1 = ReverseSeq(align1)
	align2 = ReverseSeq(align2)
	alignment := []string{align1, align2}
	return alignment
}

//ReverseSeq takes a gene sequence as input and returns the reverse of it.
func ReverseSeq(gene string) string {
	revGene := ""
	for i := len(gene) - 1; i >= 0; i-- {
		revGene += gene[i : i+1]
	}
	return revGene
}

//Part 2: Multiple Sequence Alignment -- star alignment method

//MultipleAlignment takes genes from multiple species, reward, penalty, and gap scores for pairwise alignment as inputs
//It returns a slice of strings which contain the genes after alignment by using star alignment method
func MultipleAlignment(genes []string, reward, penalty, gap int) []string {
	mAlign := []string{}

	//Get the score of each pairwise alignment for each pair of genes in genes list.
	scorematrix := ScoreMatrix(genes, reward, penalty, gap)

	//Get the row index of the row with maximum row score sum and this row is the centerGene.
	index := MaxRow(scorematrix)
	centerGene := genes[index]

	//Delete the centerGene from the gene list.
	genes = append(genes[:index], genes[index+1:]...)

	for i := range genes {
		if len(mAlign) == 0 {
			//Add the pairwise alignment of the centerGene and the first gene in the genes list to mAlign
			pAlign := AlignGenes(centerGene, genes[i], reward, penalty, gap)
			mAlign = pAlign
		} else {
			pAlign := AlignGenes(centerGene, genes[i], reward, penalty, gap)
			mcenter := mAlign[0]
			pcenter := pAlign[0]
			mcGap := CountGap(mcenter) //location of gaps for the centerGene in mAlign
			pcGap := CountGap(pcenter) //location of gaps for the centerGene in pAlign

			//rearrange mcGap according to pcGap, and pcGap according to mcGap
			mcGap, pcGap = RearrangeGap(mcGap, pcGap)

			//delete gap location if this location appears in both mcGap and pcGap
			mcGap, pcGap = UpdateGap(mcGap, pcGap)

			//reconcile any differences in gap location btw pAlign and mAlign
			for _, loc := range pcGap {
				mAlign = InsertGap(mAlign, loc)
			}
			for _, loc := range mcGap {
				pAlign = InsertGap(pAlign, loc)
			}

			//Finally, append the reconciled pairwise alignment gene to mAlign
			mAlign = append(mAlign, pAlign[1])
		}
	}
	return mAlign
}

//CountGap takes a gene as input and record the location of gaps on the gene in a slice.
func CountGap(gene string) []int {
	gapLoc := []int{}
	for i := range gene {
		if gene[i:i+1] == "-" {
			gapLoc = append(gapLoc, i)
		}
	}
	return gapLoc
}

//RearrangeGap takes in two slices which record the gap locations of the centerGene in both mAlign and cAlign
//It rearrages the mcGap according to pcGap, and pcGap according to mcGap
func RearrangeGap(mcGap, pcGap []int) ([]int, []int) {
	for idx, val := range mcGap {
		mcGap[idx] = val + CountElement(val, pcGap)
	}
	for idx, val := range pcGap {
		pcGap[idx] = val + CountElement(val, mcGap)
	}
	return mcGap, pcGap
}

//CountElement takes in a value and a slice, and counts how many elements in the slice are greater than the given value.
func CountElement(val int, gap []int) int {
	counter := 0
	for _, v := range gap {
		if v < val {
			counter++
		}
	}
	return counter
}

//UpdateGap takes in two slices, deletes the common elements in the two slices
//And subtract one from each element after the deleted elements.
func UpdateGap(mcGap, pcGap []int) ([]int, []int) {
	n := len(mcGap)
	m := len(pcGap)
	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			if mcGap[i] == pcGap[j] {
				mcGap = append(mcGap[:i], mcGap[i+1:]...)
				mcGap = Subtract(mcGap, i)
				n--
				i = 0
				pcGap = append(pcGap[:j], pcGap[j+1:]...)
				pcGap = Subtract(pcGap, j)
				m--
				j = 0
			}
		}
	}
	return mcGap, pcGap
}

//Subtract takes in a slice and an integer, and subtract one from every element with index >= integer in the slice.
func Subtract(gap []int, i int) []int {
	for k := i; k < len(gap); k++ {
		gap[k]--
	}
	return gap
}

//InsertGap takes a slice of gene sequences and an index for location as inputs and adds gap to the corresponding location in each gene in the slice.
func InsertGap(genes []string, i int) []string {
	seqs := []string{}
	for _, gene := range genes {
		newGene := ""
		newGene += gene[:i]
		newGene += "-"
		newGene += gene[i:]
		seqs = append(seqs, newGene)
	}
	return seqs
}

//ScoreMatrix takes a slice of genes as input and returns a score matrix for pairwise alignments between each two of them.
func ScoreMatrix(genes []string, reward, penalty, gap int) [][]int {
	dim := len(genes) //dimension of the matrix depends on the number of genes in the slice
	matrix := make([][]int, dim)
	for i := range matrix {
		matrix[i] = make([]int, dim)
	}
	for i := range matrix {
		for j := range matrix[i] {
			//Set the diagonal cells to 0
			if i == j {
				matrix[i][j] = 0
			}
		}
	}
	for i := 0; i <= dim-2; i++ {
		for j := i + 1; j <= dim-1; j++ {
			//Call pairwise alignment.
			alignment := AlignGenes(genes[i], genes[j], reward, penalty, gap)
			//Calculate the alignment score.
			score := AlignmentScore(alignment, reward, penalty, gap)
			matrix[i][j] = score
			matrix[j][i] = score
		}
	}
	return matrix
}

//AlignmentScore takes a slice of two gene sequences after pairwise alignment and returns an alignment score based on nucleotide match, mismatch and gap.
func AlignmentScore(genes []string, reward, penalty, gap int) int {
	score := 0
	gene1 := genes[0]
	gene2 := genes[1]
	for i := range gene1 {
		if gene1[i:i+1] == gene2[i:i+1] { //match
			score += reward
		} else if gene1[i:i+1] == "-" || gene2[i:i+1] == "-" { //gap
			score += gap
		} else { //mismatch
			score += penalty
		}
	}
	return score
}

//MaxRow takes a ScoreMatrix as input, calculates the sum of each row, and returns the row index the row index of the row with maximum row sum.
//The sequence resulting in the maximum row sum is the "center" sequence in the star alignment method.
func MaxRow(scorematrix [][]int) int {
	rowSumList := []int{} //slice to record row sum
	for i := range scorematrix {
		scoreSum := 0
		//Sum up each cell in the row
		for j := range scorematrix[i] {
			scoreSum += scorematrix[i][j]
		}
		rowSumList = append(rowSumList, scoreSum)
	}
	//Find the maximum in rowSumList.
	index := 0
	max := 0
	for i, sum := range rowSumList {
		if i == 0 || sum > max {
			index = i
			max = sum
		}
	}
	return index
}

//Part3: Use the multiple sequence alignment to build a distance matrix between each pair of species

//DistanceMatrix takes the MSA result as input and returns a matrix such that each cell corresponding to the number of mismatches between the genes of two species.
func DistanceMatrix(msa []string) [][]int {
	numSpecies := len(msa)
	dmatrix := make([][]int, numSpecies) //(len(genes)-1)*(len(genes)-1) matrix
	for i := range dmatrix {
		dmatrix[i] = make([]int, numSpecies)
	}
	for i := 0; i <= numSpecies-2; i++ {
		for j := i + 1; j <= numSpecies-1; j++ {
			mismatch := Mismatch(msa[i], msa[j])
			dmatrix[i][j] = mismatch
			dmatrix[j][i] = mismatch
		}
	}
	return dmatrix
}

//Mismatch takes two genes as inputs and returns the number of mismatches between them.
func Mismatch(gene1, gene2 string) int {
	count := 0
	for i := range gene1 {
		if gene1[i:i+1] != gene2[i:i+1] {
			count++
		}
	}
	return count
}
